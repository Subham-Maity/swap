/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from './common';

export interface PlugRouterUpgradeableInterface extends utils.Interface {
  functions: {
    'CROSS_CHAIN_SWAP_MV()': FunctionFragment;
    'DEPOSIT_MV()': FunctionFragment;
    'FEE_DENOMINATER()': FunctionFragment;
    'NATIVE_TOKEN_ADDRESS()': FunctionFragment;
    'SWAP_MV()': FunctionFragment;
    '__PlugRouterUpgradeable_init(uint256,address,address)': FunctionFragment;
    'addFeeTokens(address[],bool[])': FunctionFragment;
    'aggregatorsAndBridgesMap(bytes4)': FunctionFragment;
    'crossChainSwap(address,address,uint256,bytes4,bytes4,bytes,bytes)': FunctionFragment;
    'deposit(address,address,uint256,bytes4,bytes)': FunctionFragment;
    'feeTokens(address)': FunctionFragment;
    'isTrustedForwarder(address)': FunctionFragment;
    'lock(bytes4)': FunctionFragment;
    'owner()': FunctionFragment;
    'pause()': FunctionFragment;
    'paused()': FunctionFragment;
    'renounceOwnership()': FunctionFragment;
    'rescueTokens(address,address[],uint256[])': FunctionFragment;
    'resuceEth(address,uint256)': FunctionFragment;
    'setAggregatorsAndBridgeMap(bytes4[],address[])': FunctionFragment;
    'startOrStopParticularUserAction(bytes4,bool)': FunctionFragment;
    'swap(address,address,uint256,bytes4,bytes)': FunctionFragment;
    'swapFeeConfig()': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'trustedForwarder()': FunctionFragment;
    'unpause()': FunctionFragment;
    'updateSwapFeeConfig(uint256,address)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'CROSS_CHAIN_SWAP_MV'
      | 'DEPOSIT_MV'
      | 'FEE_DENOMINATER'
      | 'NATIVE_TOKEN_ADDRESS'
      | 'SWAP_MV'
      | '__PlugRouterUpgradeable_init'
      | 'addFeeTokens'
      | 'aggregatorsAndBridgesMap'
      | 'crossChainSwap'
      | 'deposit'
      | 'feeTokens'
      | 'isTrustedForwarder'
      | 'lock'
      | 'owner'
      | 'pause'
      | 'paused'
      | 'renounceOwnership'
      | 'rescueTokens'
      | 'resuceEth'
      | 'setAggregatorsAndBridgeMap'
      | 'startOrStopParticularUserAction'
      | 'swap'
      | 'swapFeeConfig'
      | 'transferOwnership'
      | 'trustedForwarder'
      | 'unpause'
      | 'updateSwapFeeConfig',
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'CROSS_CHAIN_SWAP_MV', values?: undefined): string;
  encodeFunctionData(functionFragment: 'DEPOSIT_MV', values?: undefined): string;
  encodeFunctionData(functionFragment: 'FEE_DENOMINATER', values?: undefined): string;
  encodeFunctionData(functionFragment: 'NATIVE_TOKEN_ADDRESS', values?: undefined): string;
  encodeFunctionData(functionFragment: 'SWAP_MV', values?: undefined): string;
  encodeFunctionData(
    functionFragment: '__PlugRouterUpgradeable_init',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'addFeeTokens',
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>[]],
  ): string;
  encodeFunctionData(functionFragment: 'aggregatorsAndBridgesMap', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(
    functionFragment: 'crossChainSwap',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'feeTokens', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'isTrustedForwarder', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'lock', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'rescueTokens',
    values: [PromiseOrValue<string>, PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'resuceEth',
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>],
  ): string;
  encodeFunctionData(
    functionFragment: 'setAggregatorsAndBridgeMap',
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<string>[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'startOrStopParticularUserAction',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<boolean>],
  ): string;
  encodeFunctionData(
    functionFragment: 'swap',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(functionFragment: 'swapFeeConfig', values?: undefined): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [PromiseOrValue<string>]): string;
  encodeFunctionData(functionFragment: 'trustedForwarder', values?: undefined): string;
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'updateSwapFeeConfig',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>],
  ): string;

  decodeFunctionResult(functionFragment: 'CROSS_CHAIN_SWAP_MV', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'DEPOSIT_MV', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'FEE_DENOMINATER', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'NATIVE_TOKEN_ADDRESS', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'SWAP_MV', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '__PlugRouterUpgradeable_init', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addFeeTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'aggregatorsAndBridgesMap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'crossChainSwap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'feeTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isTrustedForwarder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'lock', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rescueTokens', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'resuceEth', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setAggregatorsAndBridgeMap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'startOrStopParticularUserAction', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'swap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'swapFeeConfig', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'trustedForwarder', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateSwapFeeConfig', data: BytesLike): Result;

  events: {
    'CrossChainSwapPerformed(address,address,address,address,uint256,uint256,uint256,bytes4,bytes4)': EventFragment;
    'Deposit(address,address,address,uint256,uint256,bytes4)': EventFragment;
    'FeeTokens(address[],bool[])': EventFragment;
    'Initialized(uint8)': EventFragment;
    'LockedAction(bytes4,bool)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Paused(address)': EventFragment;
    'SupportedAggregatorsAndBridges(bytes4[],address[])': EventFragment;
    'SwapFeeConfigAdded(uint256)': EventFragment;
    'SwapPerformed(address,address,address,address,uint256,uint256,bytes4)': EventFragment;
    'Unpaused(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'CrossChainSwapPerformed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposit'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'FeeTokens'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'LockedAction'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SupportedAggregatorsAndBridges'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SwapFeeConfigAdded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SwapPerformed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment;
}

export interface CrossChainSwapPerformedEventObject {
  affiliateAddr: string;
  user: string;
  fromToken: string;
  toToken: string;
  amount: BigNumber;
  swapedAmount: BigNumber;
  toChainId: BigNumber;
  exchangeId: string;
  bridgeId: string;
}
export type CrossChainSwapPerformedEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, BigNumber, string, string],
  CrossChainSwapPerformedEventObject
>;

export type CrossChainSwapPerformedEventFilter = TypedEventFilter<CrossChainSwapPerformedEvent>;

export interface DepositEventObject {
  affiliateAddr: string;
  recipient: string;
  token: string;
  amount: BigNumber;
  toChainId: BigNumber;
  bridgeId: string;
}
export type DepositEvent = TypedEvent<[string, string, string, BigNumber, BigNumber, string], DepositEventObject>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface FeeTokensEventObject {
  feeTokens: string[];
  flags: boolean[];
}
export type FeeTokensEvent = TypedEvent<[string[], boolean[]], FeeTokensEventObject>;

export type FeeTokensEventFilter = TypedEventFilter<FeeTokensEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface LockedActionEventObject {
  action: string;
  lockStatus: boolean;
}
export type LockedActionEvent = TypedEvent<[string, boolean], LockedActionEventObject>;

export type LockedActionEventFilter = TypedEventFilter<LockedActionEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<[string, string], OwnershipTransferredEventObject>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface SupportedAggregatorsAndBridgesEventObject {
  ids: string[];
  routers: string[];
}
export type SupportedAggregatorsAndBridgesEvent = TypedEvent<
  [string[], string[]],
  SupportedAggregatorsAndBridgesEventObject
>;

export type SupportedAggregatorsAndBridgesEventFilter = TypedEventFilter<SupportedAggregatorsAndBridgesEvent>;

export interface SwapFeeConfigAddedEventObject {
  swapFeePercentage: BigNumber;
}
export type SwapFeeConfigAddedEvent = TypedEvent<[BigNumber], SwapFeeConfigAddedEventObject>;

export type SwapFeeConfigAddedEventFilter = TypedEventFilter<SwapFeeConfigAddedEvent>;

export interface SwapPerformedEventObject {
  affiliateAddr: string;
  user: string;
  fromToken: string;
  toToken: string;
  amount: BigNumber;
  swapedAmount: BigNumber;
  exchangeId: string;
}
export type SwapPerformedEvent = TypedEvent<
  [string, string, string, string, BigNumber, BigNumber, string],
  SwapPerformedEventObject
>;

export type SwapPerformedEventFilter = TypedEventFilter<SwapPerformedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface PlugRouterUpgradeable extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PlugRouterUpgradeableInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CROSS_CHAIN_SWAP_MV(overrides?: CallOverrides): Promise<[string]>;

    DEPOSIT_MV(overrides?: CallOverrides): Promise<[string]>;

    FEE_DENOMINATER(overrides?: CallOverrides): Promise<[BigNumber]>;

    NATIVE_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    SWAP_MV(overrides?: CallOverrides): Promise<[string]>;

    __PlugRouterUpgradeable_init(
      _swapFeePercentage: PromiseOrValue<BigNumberish>,
      _swapFeeCollector: PromiseOrValue<string>,
      _trustedForwarder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    addFeeTokens(
      tokens: PromiseOrValue<string>[],
      flags: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    aggregatorsAndBridgesMap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[string]>;

    crossChainSwap(
      affiliateAddr: PromiseOrValue<string>,
      fromToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      exchangeId: PromiseOrValue<BytesLike>,
      bridgeId: PromiseOrValue<BytesLike>,
      swapCallData: PromiseOrValue<BytesLike>,
      bridgeCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    deposit(
      affiliateAddr: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      bridgeId: PromiseOrValue<BytesLike>,
      bridgeCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    feeTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[boolean]>;

    lock(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    rescueTokens(
      withdrawableAddress: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    resuceEth(
      withdrawableAddress: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    setAggregatorsAndBridgeMap(
      ids: PromiseOrValue<BytesLike>[],
      routers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    startOrStopParticularUserAction(
      action: PromiseOrValue<BytesLike>,
      lockStatus: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    swap(
      affiliateAddr: PromiseOrValue<string>,
      fromToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      exchangeId: PromiseOrValue<BytesLike>,
      swapCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    swapFeeConfig(overrides?: CallOverrides): Promise<
      [BigNumber, string] & {
        swapFeePercentage: BigNumber;
        swapFeeCollector: string;
      }
    >;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    trustedForwarder(overrides?: CallOverrides): Promise<[string]>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

    updateSwapFeeConfig(
      _swapFeePercentage: PromiseOrValue<BigNumberish>,
      _swapFeeCollector: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  CROSS_CHAIN_SWAP_MV(overrides?: CallOverrides): Promise<string>;

  DEPOSIT_MV(overrides?: CallOverrides): Promise<string>;

  FEE_DENOMINATER(overrides?: CallOverrides): Promise<BigNumber>;

  NATIVE_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<string>;

  SWAP_MV(overrides?: CallOverrides): Promise<string>;

  __PlugRouterUpgradeable_init(
    _swapFeePercentage: PromiseOrValue<BigNumberish>,
    _swapFeeCollector: PromiseOrValue<string>,
    _trustedForwarder: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  addFeeTokens(
    tokens: PromiseOrValue<string>[],
    flags: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  aggregatorsAndBridgesMap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

  crossChainSwap(
    affiliateAddr: PromiseOrValue<string>,
    fromToken: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    exchangeId: PromiseOrValue<BytesLike>,
    bridgeId: PromiseOrValue<BytesLike>,
    swapCallData: PromiseOrValue<BytesLike>,
    bridgeCallData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  deposit(
    affiliateAddr: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    bridgeId: PromiseOrValue<BytesLike>,
    bridgeCallData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  feeTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

  lock(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  rescueTokens(
    withdrawableAddress: PromiseOrValue<string>,
    tokens: PromiseOrValue<string>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  resuceEth(
    withdrawableAddress: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  setAggregatorsAndBridgeMap(
    ids: PromiseOrValue<BytesLike>[],
    routers: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  startOrStopParticularUserAction(
    action: PromiseOrValue<BytesLike>,
    lockStatus: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  swap(
    affiliateAddr: PromiseOrValue<string>,
    fromToken: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    exchangeId: PromiseOrValue<BytesLike>,
    swapCallData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  swapFeeConfig(overrides?: CallOverrides): Promise<
    [BigNumber, string] & {
      swapFeePercentage: BigNumber;
      swapFeeCollector: string;
    }
  >;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  trustedForwarder(overrides?: CallOverrides): Promise<string>;

  unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<ContractTransaction>;

  updateSwapFeeConfig(
    _swapFeePercentage: PromiseOrValue<BigNumberish>,
    _swapFeeCollector: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    CROSS_CHAIN_SWAP_MV(overrides?: CallOverrides): Promise<string>;

    DEPOSIT_MV(overrides?: CallOverrides): Promise<string>;

    FEE_DENOMINATER(overrides?: CallOverrides): Promise<BigNumber>;

    NATIVE_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<string>;

    SWAP_MV(overrides?: CallOverrides): Promise<string>;

    __PlugRouterUpgradeable_init(
      _swapFeePercentage: PromiseOrValue<BigNumberish>,
      _swapFeeCollector: PromiseOrValue<string>,
      _trustedForwarder: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    addFeeTokens(
      tokens: PromiseOrValue<string>[],
      flags: PromiseOrValue<boolean>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    aggregatorsAndBridgesMap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;

    crossChainSwap(
      affiliateAddr: PromiseOrValue<string>,
      fromToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      exchangeId: PromiseOrValue<BytesLike>,
      bridgeId: PromiseOrValue<BytesLike>,
      swapCallData: PromiseOrValue<BytesLike>,
      bridgeCallData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    deposit(
      affiliateAddr: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      bridgeId: PromiseOrValue<BytesLike>,
      bridgeCallData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    feeTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;

    lock(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rescueTokens(
      withdrawableAddress: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    resuceEth(
      withdrawableAddress: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    setAggregatorsAndBridgeMap(
      ids: PromiseOrValue<BytesLike>[],
      routers: PromiseOrValue<string>[],
      overrides?: CallOverrides,
    ): Promise<void>;

    startOrStopParticularUserAction(
      action: PromiseOrValue<BytesLike>,
      lockStatus: PromiseOrValue<boolean>,
      overrides?: CallOverrides,
    ): Promise<void>;

    swap(
      affiliateAddr: PromiseOrValue<string>,
      fromToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      exchangeId: PromiseOrValue<BytesLike>,
      swapCallData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    swapFeeConfig(overrides?: CallOverrides): Promise<
      [BigNumber, string] & {
        swapFeePercentage: BigNumber;
        swapFeeCollector: string;
      }
    >;

    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    trustedForwarder(overrides?: CallOverrides): Promise<string>;

    unpause(overrides?: CallOverrides): Promise<void>;

    updateSwapFeeConfig(
      _swapFeePercentage: PromiseOrValue<BigNumberish>,
      _swapFeeCollector: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {
    'CrossChainSwapPerformed(address,address,address,address,uint256,uint256,uint256,bytes4,bytes4)'(
      affiliateAddr?: null,
      user?: null,
      fromToken?: null,
      toToken?: null,
      amount?: null,
      swapedAmount?: null,
      toChainId?: null,
      exchangeId?: null,
      bridgeId?: null,
    ): CrossChainSwapPerformedEventFilter;
    CrossChainSwapPerformed(
      affiliateAddr?: null,
      user?: null,
      fromToken?: null,
      toToken?: null,
      amount?: null,
      swapedAmount?: null,
      toChainId?: null,
      exchangeId?: null,
      bridgeId?: null,
    ): CrossChainSwapPerformedEventFilter;

    'Deposit(address,address,address,uint256,uint256,bytes4)'(
      affiliateAddr?: null,
      recipient?: null,
      token?: null,
      amount?: null,
      toChainId?: null,
      bridgeId?: null,
    ): DepositEventFilter;
    Deposit(
      affiliateAddr?: null,
      recipient?: null,
      token?: null,
      amount?: null,
      toChainId?: null,
      bridgeId?: null,
    ): DepositEventFilter;

    'FeeTokens(address[],bool[])'(feeTokens?: null, flags?: null): FeeTokensEventFilter;
    FeeTokens(feeTokens?: null, flags?: null): FeeTokensEventFilter;

    'Initialized(uint8)'(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    'LockedAction(bytes4,bool)'(action?: null, lockStatus?: null): LockedActionEventFilter;
    LockedAction(action?: null, lockStatus?: null): LockedActionEventFilter;

    'OwnershipTransferred(address,address)'(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null,
    ): OwnershipTransferredEventFilter;

    'Paused(address)'(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    'SupportedAggregatorsAndBridges(bytes4[],address[])'(
      ids?: null,
      routers?: null,
    ): SupportedAggregatorsAndBridgesEventFilter;
    SupportedAggregatorsAndBridges(ids?: null, routers?: null): SupportedAggregatorsAndBridgesEventFilter;

    'SwapFeeConfigAdded(uint256)'(swapFeePercentage?: null): SwapFeeConfigAddedEventFilter;
    SwapFeeConfigAdded(swapFeePercentage?: null): SwapFeeConfigAddedEventFilter;

    'SwapPerformed(address,address,address,address,uint256,uint256,bytes4)'(
      affiliateAddr?: null,
      user?: null,
      fromToken?: null,
      toToken?: null,
      amount?: null,
      swapedAmount?: null,
      exchangeId?: null,
    ): SwapPerformedEventFilter;
    SwapPerformed(
      affiliateAddr?: null,
      user?: null,
      fromToken?: null,
      toToken?: null,
      amount?: null,
      swapedAmount?: null,
      exchangeId?: null,
    ): SwapPerformedEventFilter;

    'Unpaused(address)'(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;
  };

  estimateGas: {
    CROSS_CHAIN_SWAP_MV(overrides?: CallOverrides): Promise<BigNumber>;

    DEPOSIT_MV(overrides?: CallOverrides): Promise<BigNumber>;

    FEE_DENOMINATER(overrides?: CallOverrides): Promise<BigNumber>;

    NATIVE_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    SWAP_MV(overrides?: CallOverrides): Promise<BigNumber>;

    __PlugRouterUpgradeable_init(
      _swapFeePercentage: PromiseOrValue<BigNumberish>,
      _swapFeeCollector: PromiseOrValue<string>,
      _trustedForwarder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    addFeeTokens(
      tokens: PromiseOrValue<string>[],
      flags: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    aggregatorsAndBridgesMap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    crossChainSwap(
      affiliateAddr: PromiseOrValue<string>,
      fromToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      exchangeId: PromiseOrValue<BytesLike>,
      bridgeId: PromiseOrValue<BytesLike>,
      swapCallData: PromiseOrValue<BytesLike>,
      bridgeCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    deposit(
      affiliateAddr: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      bridgeId: PromiseOrValue<BytesLike>,
      bridgeCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    feeTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;

    lock(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    rescueTokens(
      withdrawableAddress: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    resuceEth(
      withdrawableAddress: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    setAggregatorsAndBridgeMap(
      ids: PromiseOrValue<BytesLike>[],
      routers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    startOrStopParticularUserAction(
      action: PromiseOrValue<BytesLike>,
      lockStatus: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    swap(
      affiliateAddr: PromiseOrValue<string>,
      fromToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      exchangeId: PromiseOrValue<BytesLike>,
      swapCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    swapFeeConfig(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    trustedForwarder(overrides?: CallOverrides): Promise<BigNumber>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<BigNumber>;

    updateSwapFeeConfig(
      _swapFeePercentage: PromiseOrValue<BigNumberish>,
      _swapFeeCollector: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    CROSS_CHAIN_SWAP_MV(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DEPOSIT_MV(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    FEE_DENOMINATER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NATIVE_TOKEN_ADDRESS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SWAP_MV(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    __PlugRouterUpgradeable_init(
      _swapFeePercentage: PromiseOrValue<BigNumberish>,
      _swapFeeCollector: PromiseOrValue<string>,
      _trustedForwarder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    addFeeTokens(
      tokens: PromiseOrValue<string>[],
      flags: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    aggregatorsAndBridgesMap(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    crossChainSwap(
      affiliateAddr: PromiseOrValue<string>,
      fromToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      exchangeId: PromiseOrValue<BytesLike>,
      bridgeId: PromiseOrValue<BytesLike>,
      swapCallData: PromiseOrValue<BytesLike>,
      bridgeCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    deposit(
      affiliateAddr: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      bridgeId: PromiseOrValue<BytesLike>,
      bridgeCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    feeTokens(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isTrustedForwarder(forwarder: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lock(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    rescueTokens(
      withdrawableAddress: PromiseOrValue<string>,
      tokens: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    resuceEth(
      withdrawableAddress: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    setAggregatorsAndBridgeMap(
      ids: PromiseOrValue<BytesLike>[],
      routers: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    startOrStopParticularUserAction(
      action: PromiseOrValue<BytesLike>,
      lockStatus: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    swap(
      affiliateAddr: PromiseOrValue<string>,
      fromToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      exchangeId: PromiseOrValue<BytesLike>,
      swapCallData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    swapFeeConfig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    trustedForwarder(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    unpause(overrides?: Overrides & { from?: PromiseOrValue<string> }): Promise<PopulatedTransaction>;

    updateSwapFeeConfig(
      _swapFeePercentage: PromiseOrValue<BigNumberish>,
      _swapFeeCollector: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}
